---
description: Collect and validate form data.
links:
  - label: GitHub
    icon: i-simple-icons-github
    to: https://github.com/nuxtlabs/ui/blob/dev/src/runtime/components/forms/Form.ts
navigation:
  badge: Edge
---

## Usage

Use the `validate` and `state` props to validate the form. The `validate` prop is a function that takes the form state and returns an array of errors. The `state` prop is a reactive object that contains the form state.

::component-example
#default
:form-example-other

#code
```vue
<script setup lang="ts">
import { ref } from 'vue'
import type { Form, FormError } from '@nuxthq/ui/dist/runtime/types'

const state = ref({
  email: undefined,
  password: undefined
})

const rules = {
  email: (v: string) => {
    if (!v) return 'Required'
    if (!v.includes('@')) return 'Invalid email'
  },
  password: (v: string) => {
    if (!v) return 'Required'
    if (v.length < 8) return 'Must be at least 8 characters'
  }
}

const validate = async (state: any): Promise<FormError[]> => {
  return Object.entries(state)
    .map(([key, value]) => {
      const result = rules[key](value)
      if (result) return { path: key, message: result }
    })
    .filter(Boolean)
}

const form = ref<Form<any>>()

async function submit() {
  await form.value!.validate()
  // Do something with state.value
}
</script>

<template>
  <UForm
    ref="form"
    :validate="validate"
    :state="state"
    class="space-y-4 w-full"
    @submit.prevent="submit"
  >
    <UFormGroup label="Email" name="email">
      <UInput v-model="state.email" />
    </UFormGroup>

    <UFormGroup label="Password" name="password">
      <UInput v-model="state.password" type="password" />
    </UFormGroup>

    <UButton type="submit">
      Submit
    </UButton>
  </UForm>
</template>
```
::

### `yup`

You can use [Yup](https://github.com/jquense/yup) to validate the form.

The `schema` prop is a Yup schema that is used to validate the form state.

::component-example
#default
:form-example-yup

#code
```vue
<script setup lang="ts">
import { ref } from 'vue'
import { object, string, InferType } from 'yup'
import type { Form, FormError } from '@nuxthq/ui/dist/runtime/types'

const schema = object({
  email: string().email('Invalid email').required('Required'),
  password: string()
    .min(8, 'Must be at least 8 characters')
    .required('Required')
})

type Schema = InferType<typeof schema>

const state = ref({
  email: undefined,
  password: undefined
})

const form = ref<Form<Schema>>()

async function submit() {
  await form.value!.validate()
  // Do something with state.value
}
</script>

<template>
  <UForm
    ref="form"
    :schema="schema"
    :state="state"
    class="space-y-4 w-full"
    @submit.prevent="submit"
  >
    <UFormGroup label="Email" name="email">
      <UInput v-model="state.email" />
    </UFormGroup>

    <UFormGroup label="Password" name="password">
      <UInput v-model="state.password" type="password" />
    </UFormGroup>

    <UButton type="submit">
      Submit
    </UButton>
  </UForm>
</template>
```
::

### `zod`

You can use [Zod](https://github.com/colinhacks/zod) to validate the form.

The `schema` prop is a Zod schema that is used to validate the form state.

::component-example
#default
:form-example-zod

#code
```vue
<script setup lang="ts">
import { ref } from 'vue'
import { z } from 'zod'
import type { Form } from '@nuxthq/ui/dist/runtime/types'

const schema = z.object({
  email: z.string().email('Invalid email'),
  password: z.string().min(8, 'Must be at least 8 characters')
})

type Schema = z.output<typeof schema>

const state = ref({
  email: undefined,
  password: undefined
})

const form = ref<Form<Schema>>()

async function submit() {
  await form.value!.validate()
  // Do something with state.value
}
</script>

<template>
  <UForm
    ref="form"
    :schema="schema"
    :state="state"
    class="space-y-4 w-full"
    @submit.prevent="submit"
  >
    <UFormGroup label="Email" name="email">
      <UInput v-model="state.email" />
    </UFormGroup>

    <UFormGroup label="Password" name="password">
      <UInput v-model="state.password" type="password" />
    </UFormGroup>

    <UButton type="submit">
      Submit
    </UButton>
  </UForm>
</template>
```
::

### `joi`

You can use [Joi](https://github.com/hapijs/joi) to validate the form.

The `schema` prop is a Joi schema that is used to validate the form state.

::component-example
#default
:form-example-joi

#code
```vue
<script setup lang="ts">
import { ref } from 'vue'
import Joi from 'joi'
import type { Schema } from 'joi'
import type { Form } from '@nuxthq/ui/dist/runtime/types'

const schema = Joi.object({
  email: Joi.string().required(),
  password: Joi.string()
    .min(8)
    .required()
})

const state = ref({
  email: undefined,
  password: undefined
})

const form = ref<Form<Schema>>()

async function submit () {
  await form.value!.validate()
  // Do something with state.value
}
</script>

<template>
  <UForm
    ref="form"
    :schema="schema"
    :state="state"
    class="space-y-4 w-full"
    @submit.prevent="submit"
  >
    <UFormGroup label="Email" name="email">
      <UInput v-model="state.email" />
    </UFormGroup>

    <UFormGroup label="Password" name="password">
      <UInput v-model="state.password" type="password" />
    </UFormGroup>

    <UButton type="submit">
      Submit
    </UButton>
  </UForm>
</template>
```
::

## Example

::component-example
#default
:form-example-all-inputs

#code
```vue
<script setup lang="ts">
import { ref } from 'vue'
import { z } from 'zod'
import type { Form } from '@nuxthq/ui/dist/runtime/types'

const options = [
  { label: 'Option 1', value: 'option-1' },
  { label: 'Option 2', value: 'option-2' },
  { label: 'Option 3', value: 'option-3' }
]

const state = ref({
  input: undefined,
  textarea: undefined,
  select: undefined,
  selectMenu: undefined,
  checkbox: undefined,
  toggle: undefined,
  radio: undefined,
  switch: undefined,
  range: undefined
})

const schema = z.object({
  input: z.string().min(10),
  textarea: z.string().min(10),
  select: z.string().refine(value => value === 'option-2', {
    message: 'Select Option 2'
  }),
  selectMenu: z.any().refine(option => option?.value === 'option-2', {
    message: 'Select Option 2'
  }),
  toggle: z.boolean().refine(value => value === true, {
    message: 'Toggle me'
  }),
  check: z.boolean().refine(value => value === true, {
    message: 'Check me'
  }),
  radio: z.string().refine(value => value === 'option-2', {
    message: 'Select Option 2'
  }),
  range: z.number().max(20, { message: 'Must be less than 20' })
})

type Schema = z.infer<typeof schema>

const form = ref<Form<Schema>>()

async function submit () {
  await form.value!.validate()
  // Do something with state.value
}
</script>

<template>
  <UForm
    ref="form"
    :schema="schema"
    :state="state"
    class="space-y-4 w-full"
    @submit.prevent="submit"
  >
    <UFormGroup name="input" name="input" label="Input">
      <UInput v-model="state.input" />
    </UFormGroup>

    <UFormGroup name="textarea" name="textarea" label="Textarea">
      <UTextarea v-model="state.textarea" />
    </UFormGroup>

    <UFormGroup name="select" name="select" label="Select">
      <USelect v-model="state.select" placeholder="Select..." :options="options" />
    </UFormGroup>

    <UFormGroup name="selectMenu" name="selectMenu" label="Select Menu">
      <USelectMenu v-model="state.selectMenu" placeholder="Select..." :options="options" />
    </UFormGroup>

    <UFormGroup name="toggle" name="toggle" label="Toggle">
      <UToggle v-model="state.toggle" />
    </UFormGroup>

    <UFormGroup name="checkbox" name="checkbox" label="Checkbox">
      <UCheckbox v-model="state.checkbox" />
    </UFormGroup>

    <UFormGroup name="radio" name="radio" label="Radio">
      <URadio v-for="option in options" :key="option.value" v-model="state.radio" v-bind="option">
        {{ option.label }}
      </URadio>
    </UFormGroup>

    <UFormGroup name="range" name="range" label="Range">
      <URange v-model="state.range" />
    </UFormGroup>

    <UButton type="submit">
      Submit
    </UButton>
  </UForm>
</template>
```
::

## Props

:component-props
